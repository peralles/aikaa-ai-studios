/constitution Create principles focused on code quality, user interface and user experience consistency having a great performance as requirements. Include governance for how these principles should guide technical decisions and implementation choices. Do not over engineer on tests and implementation.

/specify Aikaa AI Studio is a team productivity platform designed for multi-tenant management. The platform is built to host multiple independent tenants, where each tenant represents a Parent Company (the headquarters or main entity). Under a single Parent Company, the system allows for the management of multiple associated entities, such as subsidiaries, franchisees, partners, or other B2B relationships. Users are associated with the companies and can have flexible access, including access to only one specific company, multiple associated companies, or the Parent Company itself. Users are designated as either Normal Users or Admin Users; Admin Users possess special configuration and management powers within their assigned company scope. Finally, a specialized class of users will have Platform-Level Admin status, granting them complete, unrestricted access across the entire Aikaa AI Studio platform. The platform design will also allow for the future implementation of other highly-specific, platform-wide administrative roles. To manage specific company workflows, the platform incorporates Studios at the company level. Each Studio functions as a dedicated Kanban board, which is structured by sequential stages or columns that define a process. A critical rule for the Studio system is that each individual Kanban board can only manage one specific type of generic card entity. These Cards are highly versatile entities that can be configured by the company to represent various items—such as a Lead, Opportunity, Customer, Sales Transaction, or Project Task—but a given Studio (Kanban board) must maintain consistency by focusing solely on one of these chosen types. This ensures clarity and operational efficiency within each defined workflow.

/plan "We are going to generate this using a **modern, full-stack architecture** centered around **React, TypeScript, and Supabase**. The focus is on a high-performance, maintainable, and highly-typed application using best-in-class tools for every layer of the stack.

### Core Technology Stack

The **Frontend** is built on **React (18.3.1)**, utilizing **Vite (5.4.19)** as an ultra-fast build tool and dev server. The entire codebase is written in **TypeScript (5.8.3)** to ensure static type checking and improved developer experience. **React Router DOM (6.30.1)** handles the Single Page Application (SPA) routing seamlessly.

For the **User Interface and Design System**, the project leverages a **component-based design** approach. **shadcn/ui**, which is built on top of the accessible primitives provided by **Radix UI**, forms the core design system. Styling is managed by **Tailwind CSS (3.4.17)**, a utility-first framework, enhanced with **tailwindcss-animate (1.0.7)** for smooth CSS animations and **@tailwindcss/typography (0.5.19)** for optimized text rendering. **next-themes (0.3.0)** provides robust support for a dark/light theme system, and **Lucide React (0.462.0)** supplies a comprehensive set of SVG icons.

The **Backend and Database** are fully managed by **Supabase (2.58.0)**, a powerful Backend-as-a-Service solution. This includes a robust **PostgreSQL database**, **Row Level Security (RLS)** for secure data access, **Realtime subscriptions**, built-in **Authentication & Authorization**, and **Edge Functions** for serverless logic. Database schema management and migrations are handled using the **Supabase CLI**.

### State, Data Flow, and Form Management

**Server State and Data Fetching** are expertly managed by **TanStack Query (5.83.0)**, which provides intelligent caching, background updates, optimistic updates for a responsive UX, and consistent error handling. Global application state, such as authentication and language settings, is handled via the native **React Context API**.

**Forms and Validation** adhere to a robust standard. **React Hook Form (7.61.1)** manages form state, controls, and submission. Validation is performed using **Zod (3.25.76)**, a TypeScript-first schema validation library, integrated via **@hookform/resolvers (3.10.0)**.

A collection of **Specialized UI Components** ensures a rich user experience, including **embla-carousel-react (8.6.0)** for carousels, **react-day-picker (8.10.1)** for date selection, **recharts (2.15.4)** for data visualization, **cmdk (1.1.1)** for a command palette, **sonner (1.7.4)** for elegant toast notifications, **vaul (0.9.9)** for drawer/modal components, and **input-otp (1.4.2)** for one-time password inputs.

Utility functions are standardized using libraries like **clsx (2.1.1)** for conditional CSS classes, **tailwind-merge (2.6.0)** for safely merging Tailwind class strings, **class-variance-authority (0.7.1)** for creating variant-based component styling, and **date-fns (3.6.0)** for reliable date manipulation. Code quality is maintained with **ESLint (9.32.0)** and **@typescript-eslint (8.38.0)**.

### Project Architecture and Patterns

The project follows a logical **Folder Structure** within `src/`, separating concerns into `components/` (further divided into `ui/` for base components and feature-specific folders), `contexts/`, `hooks/`, `integrations/` (e.g., Supabase configuration), `lib/` (general utilities), `pages/`, and `assets/`. This organization promotes clarity and modularity.

The **Architectural Patterns** are defined by four core principles. A **Supabase-First Architecture** dictates direct integration with the platform for all data operations, strict use of **RLS**, automatic type generation from the schema, and use of real-time subscriptions where needed. The **Component-Based Design System** relies on **shadcn/ui** and promotes **composition over inheritance**, controlled variants via `class-variance-authority`, and assured **accessibility** through Radix UI. **Server State Management** via TanStack Query focuses on strategic **query invalidation**, automatic **background refetching**, and **optimistic updates** for a fluid feel. Finally, a **Multilingual Architecture** employs **Context-based** language switching, supports bilingual content at the **database level**, and uses browser detection for setting a default language.

### Development and Deployment

**UI/UX Strategies** emphasize a modern, **responsive design** using the **shadcn/ui** design tokens and **Tailwind CSS** mobile-first approach. Interactions are enhanced with **smooth transitions**, subtle **hover effects**, clear **loading states**, and strategic use of **staggered animations** for lists. **Accessibility** is a priority, ensuring **keyboard navigation**, screen reader compatibility, and optimized **focus management** provided by Radix UI.

**Development Patterns** are rigorously applied. **React Patterns** include extensive use of **Custom Hooks** for reusable logic, **Compound Components** for flexibility, and **Error Boundaries** for application robustness. **TypeScript Patterns** utilize **strict mode**, **Interface Segregation** for props, and advanced features like **Generic Types** and **Discriminated Unions**. **Data Fetching Patterns** ensure organized **Query Keys**, defined **Mutation Callbacks** for side effects, and a consistent approach to **Error Handling** and **Cache Invalidation**.

For **Deployment**, the **Build Process** is handled by **Vite** for an optimized, dynamic bundle with automatic asset optimization, code splitting, and tree shaking. The system utilizes structured **Environment Variables** (e.g., `VITE_SUPABASE_URL`) to manage configuration for different environments. **Supabase Configuration** uses the **CLI** for **local development** and **versioned migration management**, supporting clear **environment separation** (dev/prod) and leveraging automatic database backups."